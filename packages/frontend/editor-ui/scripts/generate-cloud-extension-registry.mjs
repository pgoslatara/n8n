#!/usr/bin/env node

import { writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { discoverExtensions } from './discover-cloud-extensions.mjs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const OUTPUT_PATH = join(__dirname, '../src/extensions/registry.generated.ts');

function getExtensionPoints(manifest) {
	// Return all extension points from manifest
	if (manifest.extends && typeof manifest.extends === 'object') {
		return Object.keys(manifest.extends);
	}
	return [];
}

function generateRegistryCode(extensions) {
	const frontendExtensions = extensions.filter((p) => p.hasFrontend);

	// Generate static imports at the top
	const imports = frontendExtensions
		.map((p, idx) => {
			return `// @ts-expect-error This is resolved in vite
import * as extension${idx} from '${p.resolvedName}/frontend/index';`;
		})
		.join('\n');

	const entries = frontendExtensions
		.map((p, idx) => {
			const extensionPoints = getExtensionPoints(p.manifest);
			const extensionPointsJson = JSON.stringify(extensionPoints);

			// Reference the statically imported extension - access shouldLoad through default export
			const shouldLoadLine = `    shouldLoad: extension${idx}.default?.shouldLoad,`;

			return `  {
    name: '${p.name}',
    resolvedName: '${p.resolvedName}',
    module: extension${idx},
${shouldLoadLine}
    extensionPoints: ${extensionPointsJson},
    manifest: ${JSON.stringify(p.manifest, null, 4).replace(/\n/g, '\n    ')},
  }`;
		})
		.join(',\n');

	return `// This file is auto-generated by scripts/generate-extension-registry.mjs
// Do not edit manually!

/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */

import type { ExtensionManifest } from '@n8n/extension-sdk/validation';
import type { FrontendExtension } from '@n8n/extension-sdk/frontend';

${imports}

export interface ExtensionDefinition {
  name: string;
  resolvedName: string;
  module: { default: FrontendExtension };
  shouldLoad?: () => Promise<boolean>;
  extensionPoints: string[];
  manifest: ExtensionManifest;
}

export const EXTENSIONS: ExtensionDefinition[] = [
${entries}
];
`;
}

async function generateExtensionRegistry() {
	console.log('ğŸ” Discovering extensions...');
	const extensions = await discoverExtensions();

	console.log('ğŸ“ Generating extension registry...');
	const code = generateRegistryCode(extensions);

	writeFileSync(OUTPUT_PATH, code, 'utf-8');
	console.log(`âœ“ Generated extension registry: ${OUTPUT_PATH}\n`);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	generateExtensionRegistry().catch((error) => {
		console.error('âŒ Registry generation failed:', error);
		process.exit(1);
	});
}

export { generateExtensionRegistry };
